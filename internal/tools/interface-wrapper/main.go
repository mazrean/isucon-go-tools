package main

import (
	"encoding/json"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"os"
	"strconv"
)

type Config struct {
	Pkg     string `json:"package"`
	Func    string `json:"func"`
	Imports []struct {
		Name string `json:"name,omitempty"`
		Path string `json:"path"`
	} `json:"imports"`
	RequiredInterface  Interface   `json:"requiredInterface"`
	OptionalInterfaces []Interface `json:"optionalInterfaces"`
}

type Interface struct {
	Package string `json:"package,omitempty"`
	Name    string `json:"name"`
}

func (i *Interface) expr() ast.Expr {
	if len(i.Package) == 0 {
		return ast.NewIdent(i.Name)
	}

	return &ast.SelectorExpr{
		X:   ast.NewIdent(i.Package),
		Sel: ast.NewIdent(i.Name),
	}
}

func main() {
	var config Config
	err := json.NewDecoder(os.Stdin).Decode(&config)
	if err != nil {
		panic(fmt.Errorf("failed to decode config json: %w", err))
	}

	fset := token.NewFileSet()

	importSpecs := make([]*ast.ImportSpec, 0, len(config.Imports))
	importSpecForDecls := make([]ast.Spec, 0, len(config.Imports))
	for _, impt := range config.Imports {
		var name *ast.Ident
		if len(impt.Name) != 0 {
			name = ast.NewIdent(impt.Name)
		}

		importSpec := ast.ImportSpec{
			Name: name,
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: strconv.Quote(impt.Path),
			},
		}

		importSpecs = append(importSpecs, &importSpec)
		importSpecForDecls = append(importSpecForDecls, &importSpec)
	}

	var (
		valueIdent        = ast.NewIdent("v")
		wrapFuncIdent     = ast.NewIdent("wrapper")
		wrappedValueIdent = ast.NewIdent("wrapped")
		wrappedTypeIdent  = ast.NewIdent(config.Func + "WrappedType")
	)

	valueType := config.RequiredInterface.expr()

	fields := make([]*ast.Field, 0, len(config.OptionalInterfaces)+1)
	fields = append(fields, &ast.Field{
		Type: valueType,
	})
	for _, intrfc := range config.OptionalInterfaces {
		fields = append(fields, &ast.Field{
			Type: intrfc.expr(),
		})
	}
	var wrappedType ast.Expr = &ast.InterfaceType{
		Methods: &ast.FieldList{
			List: fields,
		},
	}

	_, err = io.WriteString(os.Stdout, "// Code generated by internal/tools/interface-wrapper.go; DO NOT EDIT.\n")
	if err != nil {
		panic(fmt.Errorf("failed to write header: %w", err))
	}

	f := ast.File{
		Name:    ast.NewIdent(config.Pkg),
		Imports: importSpecs,
		Decls: []ast.Decl{
			&ast.GenDecl{
				Tok:   token.IMPORT,
				Specs: importSpecForDecls,
			},
			&ast.GenDecl{
				Tok: token.TYPE,
				Specs: []ast.Spec{&ast.TypeSpec{
					Name:   wrappedTypeIdent,
					Assign: token.Pos(100),
					Type:   wrappedType,
				}},
			},
			&ast.FuncDecl{
				Name: ast.NewIdent(config.Func),
				Type: &ast.FuncType{
					Params: &ast.FieldList{
						List: []*ast.Field{{
							Names: []*ast.Ident{
								valueIdent,
							},
							Type: valueType,
						}, {
							Names: []*ast.Ident{
								wrapFuncIdent,
							},
							Type: &ast.FuncType{
								Params: &ast.FieldList{
									List: []*ast.Field{{
										Type: valueType,
									}},
								},
								Results: &ast.FieldList{
									List: []*ast.Field{{
										Type: wrappedTypeIdent,
									}},
								},
							},
						}},
					},
					Results: &ast.FieldList{
						List: []*ast.Field{{
							Type: valueType,
						}},
					},
				},
				Body: &ast.BlockStmt{
					List: getBody(valueIdent, wrapFuncIdent, wrappedValueIdent, valueType, &config.RequiredInterface, config.OptionalInterfaces),
				},
			},
		},
	}

	format.Node(os.Stdout, fset, &f)
}

func getBody(valueIdent, wrapFuncIdent, wrappedValueIdent *ast.Ident, valueType ast.Expr, requiredInterfaces *Interface, optionalInterfaces []Interface) []ast.Stmt {
	if len(optionalInterfaces) == 0 {
		return []ast.Stmt{&ast.ReturnStmt{
			Results: []ast.Expr{valueIdent},
		}}
	}

	indexIdent := ast.NewIdent("i")
	bodyStmts := []ast.Stmt{
		&ast.AssignStmt{
			Tok: token.DEFINE,
			Lhs: []ast.Expr{wrappedValueIdent},
			Rhs: []ast.Expr{&ast.CallExpr{
				Fun:  wrapFuncIdent,
				Args: []ast.Expr{valueIdent},
			}},
		},
		&ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{&ast.ValueSpec{
					Names: []*ast.Ident{indexIdent},
					Type:  ast.NewIdent("uint64"),
				}},
			},
		},
	}

	constSpecs := make([]ast.Spec, 0, len(optionalInterfaces))
	checkStmts := make([]ast.Stmt, 0, len(optionalInterfaces))
	for i, intrfc := range optionalInterfaces {
		ident := ast.NewIdent(fmt.Sprintf("i%d", i))
		var values []ast.Expr
		if i == 0 {
			values = []ast.Expr{&ast.BinaryExpr{
				X: &ast.BasicLit{
					Kind:  token.INT,
					Value: "1",
				},
				Op: token.SHL,
				Y:  ast.NewIdent("iota"),
			}}
		}

		constSpecs = append(constSpecs, &ast.ValueSpec{
			Names:  []*ast.Ident{ident},
			Values: values,
		})

		okIdent := ast.NewIdent("ok")
		checkStmts = append(checkStmts, &ast.IfStmt{
			Init: &ast.AssignStmt{
				Lhs: []ast.Expr{ast.NewIdent("_"), okIdent},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{&ast.TypeAssertExpr{
					X:    valueIdent,
					Type: intrfc.expr(),
				}},
			},
			Cond: okIdent,
			Body: &ast.BlockStmt{
				List: []ast.Stmt{&ast.AssignStmt{
					Lhs: []ast.Expr{indexIdent},
					Tok: token.OR_ASSIGN,
					Rhs: []ast.Expr{ident},
				}},
			},
		})
	}

	bodyStmts = append(bodyStmts, &ast.DeclStmt{
		Decl: &ast.GenDecl{
			Tok:   token.CONST,
			Specs: constSpecs,
		},
	})
	bodyStmts = append(bodyStmts, checkStmts...)

	caseClauseStmts := make([]ast.Stmt, 0, 1<<len(optionalInterfaces))
	var i uint64 = 0
	for ; i < 1<<len(optionalInterfaces); i++ {
		typeFields := []*ast.Field{{
			Type: valueType,
		}}
		elementsExprs := []ast.Expr{wrappedValueIdent}

		tmpI := i
		for j := 0; j < len(optionalInterfaces); j++ {
			if tmpI&1 != 0 {
				typeFields = append(typeFields, &ast.Field{
					Type: optionalInterfaces[j].expr(),
				})
				elementsExprs = append(elementsExprs, wrappedValueIdent)
			}
		}

		caseClauseStmts = append(caseClauseStmts, &ast.CaseClause{
			List: []ast.Expr{&ast.BasicLit{
				Kind:  token.INT,
				Value: strconv.FormatUint(i, 10),
			}},
			Body: []ast.Stmt{&ast.ReturnStmt{
				Results: []ast.Expr{&ast.CompositeLit{
					Type: &ast.StructType{
						Fields: &ast.FieldList{
							List: typeFields,
						},
					},
					Elts: elementsExprs,
				}},
			}},
		})
	}

	bodyStmts = append(bodyStmts, &ast.SwitchStmt{
		Tag: indexIdent,
		Body: &ast.BlockStmt{
			List: caseClauseStmts,
		},
	}, &ast.ReturnStmt{
		Results: []ast.Expr{valueIdent},
	})

	return bodyStmts
}
